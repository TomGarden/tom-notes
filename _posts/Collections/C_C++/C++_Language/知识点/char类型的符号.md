
**char / signed char / unsigned char**

我们知道 char 类型 占 8 个比特位 , 
- unsigned char 范围 0 ~ 255
-   signed char 范围 -128 ~ 127
- char 实际上是上述两种中的一种 , 具体那种不同编译器有不同理解 . 

我的问题在于
1. 为什么有符号后的数据范围与我们理解的不太相同, 我理解应该 `-127 ~ 127`
2. 要么就是读书的时候没有好好读 , 要么就是过了些年忘了 , 我倾向于是前者 . 


## 0x0. 数制 

计数系统 / 数字系统 / 数制  , 叫法不同 , 是一个含义 . 
将数字按位 , 赋予人类理解的含义 
```
/*我们常见的十进制数*/
万  千  百  十  个
5   4   3   2  1
``` 

十进制按位计数 , 逢十进一 , 所以十进制中某一个位最大表示的数是 九 .

类比扩展可以得到 任意进制的 数字逻辑. 

比较常见的有 二进制 / 八进制 / 十六进制 

不同进制的数 , 都可以表示任意大小的数字 , 差别就 : 同一个数值的数字用不同数制表示书写的时候长短不同 . 

目前可以理解的最小的数制就是二进制 . 可以假设下 , 如果尝试用 一进制数 , 我们可用的数字符号就只有 `0` 了 , 只有这一个符号 , 连续放再多都是无法承载信息的 . 

二进制是目前已知的可以承载信息的最小的数制 . 

计算机中的数据是用 二进制 数来保存和表达的 . 


## 0x1. 码制

计算机处理数据的时候 , 到硬件层面是在处理连续的电信号 . 

计算机领域的先驱们, 选定了两个电信号作为计算机可以理解的信号 :  `高电压` / `低电压` .

计算机只会计算加法 .  减法 / 乘法 / 除法 都是可以转换为加法运算的 . 

### 1.1. 常见的对二进制数的操作 & 逻辑门 

这些逻辑关系恰好可以通过继电器转换为电气化的表达 . 逻辑内含不变 . 

计算机在其内部也确实是用无数微小的继电器来组装运行的 . 

这里没有给出逻辑电路的图片 , 只给出了逻辑上二进制数的按位操作示例 . 

现在我们来捋一下 : 
1. 计算机的运算核心器件是一个叫 `加法器` 的东西 , 它只会做加法 , `减/乘/除`都可以转换为加法运算 . 
    所以一个加法器也就足够四则运算了 . 
2. 加法器是用逻辑电路组织拼装的 . 
3. 二进制数所能表示的逻辑关系 , 逻辑电路都可以表示 . 


二进制按位操作逻辑关系示例 : 
1. 与(AND)  
    ```
        0101
    AND 0011
      = 0001
    ```
2. 或(OR) 
    ```
       0101（十进制5）
    OR 0011（十进制3）
     = 0111（十进制7）
    ```
3. 取反/非(NOT)  : `!1 = 0` , `!0 = 1`
    ```
    NOT 0111（十进制7）
      = 1000（十进制8）
    ```

4. 或非(NOR) : 先做或(2)后做非(3/取反)
    ```
        0011
    NOR 0101
      = 1000
    ```

5. 异或(XOR) : 同则为0 , 异则为1
    ```
        0101
    XOR 0011
      = 0110
    ```


## 0x2. 尝试将十进制类比扩展一下 . 
- 可能因为人类有 十 根手指 , 所以我们用了 十进制数 .  
    - 在十进制的情况下 , 我们有十个符号 : `0, 1, 2, 3, 4, 5, 6, 7, 8, 9` , 我们用这十个符号可以表示任意大的数字 . 
- 恐龙只有 八 根手指 , 让他们来发展数学 , 它们可能会采用十进制数吧 . 
    - 在八进制的情况下 , 恐怕只能有八个符号了 : `0, 1, 2, 3, 4, 5, 6, 7` , 这也足够用来表示任意大的数字 , 只是位数会多一点 .
- 鲸鱼只有 两 根胳膊 , 让他们发展数学 , 它们可能采用 二 进制数吧 . 
    - 在二进制的情况下 , 恐怕只能有二个符号了 : `0, 1` , 这也足够用来表示任意大的数字 , 只是位数会更多一点 .

不论是扩展得到的那种进制, 都不可避免的可以进位得到 `10(一零)` , `100(一零零)` , `1000(一零零零)` , ··· 

## 0x3. 补数

**补数(数学概念)** : 补数（complement）是对于给定的进位制，相加后能使自然数 a 的位数增加 1 的最小的数。
- 假设有一个 `n+1` 进制数 `xxx` , 要计算它的补数 , 有两种思路 : 
    1. 对于 `n+1` 的补数 =  nnn - xxx + 1 
    2. 对于 `n+1` 的补数 = 1000 - xxx
    3. 没有写出这两个算式来 , 我没想到它们竟是如此相近的两个思路 . 

- 在计算加减法的过程中 , `a - b` 的结果与 `a + b的补数` 的结果相同 . (忽略高位溢出的情况下成立)
    - 考虑一位十进制数 
      - 2 对于 **十** 的补数是 8(9-2+1) ; `3-2 = 1` , `3+8 = 11(由于我们考虑的是一位十进制数 , 溢出的高位数被忽略)` 
      - 可以说 , 是成立的 . 
    - 二进制中 按位计算补数 , 1 对于 **二** 的补数是 1 
        - 如果要计算 1010 - 0001 , 我们也可以换算为求和的形式 . 溢出的高位被忽略的情况下 , 可以说是成立的 . 
          ```
            与补数求和         人类正常计算           计算减数的补数                                          
               1010      |        1010      |           0001
            +  1111      |     -  0001      | 
            = 11001      |     =  1001      |     补码为 1111
          ```


## 0x4. 考虑一个环 

以十进制为例 . 我们能不能只占用一个位 , 表示出 `-5 ~ 4` 这十个数 ? 
- 要做到这些 , 我们必须为数字定义我们自己的含义 
- 如果不定义如下的映射关系 , 负号 也要占一位的话 , 恐怕比较难做到题干的要求

| 至少两位 |一位数映射|
|:------:|:------:|
|  -5    |    5   |      
|  -4    |    6   |      
|  -3    |    7   |      
|  -2    |    8   |      
|  -1    |    9   |      
|  0     |    0   |     
|  1     |    1   |     
|  2     |    2   |     
|  3     |    3   |     
|  4     |    4   |     

还是只能占一个位 , 我们用上面的映射表得到的新的意义的数字进行`加减乘除`运算是否可行呢 ? 

- 先观察一下 , 我们用 十个 一位 数字做了一个环(如果首尾相接的话)
    - 对于映射列 , 如果不考虑映射关系 , 只把映射列当做普通字面意思的十进制数 . 任意取一个数 , 不断做 +1 操作 , 会发现被困在了一个环里
    - 如果要计算 `-5 + 4` , 用我们新定义的映射表 , 做的操作是 , `5 + 4 = 9` 
    - 再计算一下 `-1 + 3` , 用新定义的映射表 , 做的操作是 : `9 + 3 = 12(溢出位的"1"会被忽略 , 因为我们目前只能占一个位)`
    - 在这里我们虽然用了映射后的数 , 但是运算规则还是按照正常十进制的运算规则来算的 , 得到的结果再映射表中找到对应的值 , 含义也是自洽的 . 

- 只要没有人可以举出反例 , 就可以说上述逻辑是成立的了 . 

我们把数字做一个排列再看下 , 每一列上下两个数都
- 互相为自己对于 9 的补数
- 互相比自己对于 10 的补数 小 1 

  ```
              5
           6  
        7 
     8
  9  

  0  
     1  
        2  
           3  
              4
  ```

## 0x5. 结合二进制考虑一个环 (假设我们能处理的最大位数为 4 )

看这16个数 , 现在我们尝试用二进制做一个环 , 用二进制表示 `-8 ~ 7` 的16个数 , 只能占 4 个二进制位 . 
- ①: 十进制的 0 ~ 15
- ②: 二进制的无符号数 0000(0) ~ 1111(15)
- ③: 十进制的 -8 ~ 7
- ④: 二进制自行映射的 -8 ~ 7 , 实际上是二进制有符号数


```
 ①        ②              ③          ④                                 ⑤ 
十进制    二进制     |   十进制释义     我们的环       做一个垂直方向视觉上的对应关系 , 方便后续解说   说   说     说 
                
  0      0000      |      -8         1000                                                           1000 
  1      0001      |      -7         1001                                                    1001 
  2      0010      |      -6         1010                                             1010 
  3      0011      |      -5         1011                                      1011 
  4      0100      |      -4         1100                               1100 
  5      0101      |      -3         1101                        1101 
  6      0110      |      -2         1110                 1110 
  7      0111      |      -1         1111          1111 
         
  8      1000      |       0         0000          0000 
  9      1001      |       1         0001                 0001 
 10      1010      |       2         0010                        0010 
 11      1011      |       3         0011                               0011 
 12      1100      |       4         0100                                      0100 
 13      1101      |       5         0101                                             0101 
 14      1110      |       6         0110                                                    0110 
 15      1111      |       7         0111                                                           0111 
``` 


不要忘记我们的前提是假设我们只能使用 4 个二进制位 . 

我们先观察下这五个列 :
- ①  ③ 没有什么特别的 , 是十进制数
- 第 ② 列 就是 二进制原码
    - 原码是指一个二进制数左边加上符号位后所得到的码，且当二进制数大于0时，符号位为0；
      二进制数小于0时，符号位为1；二进制数等于0时，符号位可以为0或1(+0/-0)。
    - 对于无符号数 , 来说第二列就是原码 , 无符号数实际上当做正数处理 .   
- 第 ④ 列是我们自行映射的值 , 我们用 `1000 映射到 二进制的负八` , `1001 映射到二进制负七` , ···
- 第 ⑤ 列 , 是我们为了方便观察这个映射的其他细节做的一点格式化 , 仅此而已
    - 现在已经不难看出了 , 第 ⑤ 列中的每一个纵上的两个数 , 在二进制中 互为反码 .
        - 反码（英语：1's complement）是一种在计算机中数的机器码表示。
          对于单个数值（二进制的0和1）而言，对其进行取反操作就是将0变为1，1变为0。
    - 针对第⑤列 , 不难看出 : 负数最高位为 1 , 正数最高位为 0 (0算正数), 事实上最高位在二进制中是可以被理解为为符号位的 . 
    - 针对第⑤列 , 不难看出 :  `0111(正七)` 间 `1001(负七)` 存在微秒的关系
        - 我们称 `1001` 为`负七`的补码
        - 不难看出 , `负七` 的补码 `1001` 就是 `0111(正七)` 先按位取反 `1000` 再加一 `1001` 后的值
        - 补码（英语：2's complement）是一种用二进制表示有符号数的方法，也是一种将数字的正负号变号的方式，常在电脑科学中使用。
          补码以有符号位元的二进制数定义。
          正数和0的补码就是该数字本身再补上最高位元0。
          **负数的补码则是将其对应正数按位取反再加1**。

在二进制下 , 这样一个环 , 如果我们需要进行 `加减乘除` :
1. 两个小例子 , 纵向查看
    ```
    计算下 -6 + 2          2 + 3         -2 + -3          计算下 -3 + 7
        1010(-6)      |   0010(2)   |      1010(-2)   |        1101(-3)   
     +  0010(+2)      | + 0011(3)   |    + 1011(-3)   |     +  0111(+7)
     =  1100(-4)      | = 0101(5)   |    = 1101(-5)   |     - 10100(+4) : (我们处理的最大位数位4 , 超出的被忽略了)
    ```

## 0x6. 小结
综上 , 可知 :
1. 计算机中使用二进制补码表示负数时 , 可以方便的通过加法器 , 完成 `加减乘除` 四则运算 . 这方便了实际问题的解决 . 
2. 我们称计算机存储二进制的方式为 , 使用补码存储 . 
    - 为了与之逻辑自洽 , 我们称正数的原码/反码/补码都是其自身 . 
3. 正数的 原码 / 反码 / 补码都是一样的 . 
    - 但是一个二进制数 , 仍然需要根据上下文 理解 `取反 / 求补` 的含义 . 


## 0x07. 应用

现在我们把上面的知识应用到实际中

我们知道 char 类型 占 8 个比特位 , 
- unsigned char 范围 0 ~ 255
    - 是的 , 这确实是 , 8个比特位所能表示的所有数字
-   signed char 范围 -128 ~ 127
    - 还记得我们的环吗 , 这确实是 8 个比特位所能表示的所有有符号数 


## 0x08. 跑下题

1. char 类型的变量为什么还要分有符号和无符号 ? 
2. 我问的不是 , signed char / unsigned char 有什么不同 . 
3. 我想为为什么设计者要保留这种不同 ? 

我找到了这里 : 
1. https://publications.gbdirect.co.uk//c_book/chapter2/integral_types.html
2. https://stackoverflow.com/a/4337252/7707781

我认为 char , 之所以有 singed / unsigned 修饰符 , 只是因为 , char 本质上是 一个 int . 

只是用这个 int 的值和 ascii 符号 做了一个公认的映射关系 . 方便字符操作和处理 . 
- char 一般至少可以表示 127 个数字
- 随着 语言的国际化 , char 能表示的 范围也越来越大 
    - 在 c++ 里有了 char16_t , char32_t , wchar_t

所以它具有 int 所具有的特性 : 符号 . 

计算机尝试理解数字的时候 , 可以指定 , 某个内存区域内的位 , 按照有符号数理解还是按照无符号数理解 . 




## 参考信息 · 从下列位置抄袭而来

0. **重点参考 : 《编码：隐匿在计算机软硬件背后的语言》(Charles Petzold)** `12章`/`13章`
    - 可以说上面的文字的大部分就是从这里抄来的

1. https://zh.wikipedia.org/wiki/记数系统
2. https://www.stepfpga.com/doc/码制
3. https://zh.m.wikipedia.org/zh-hans/原码
4. https://zh.m.wikipedia.org/zh-hans/反码
    - https://web.archive.org/web/20181108105426/http://210.44.176.183/jsjxy/jsjzcyl/教学课件/Chap02/2.1.2.htm
5. 补码 : https://zh.wikipedia.org/zh-sg/二補數
    - https://zh.m.wikipedia.org/zh-hans/补数
6. 计算机组成与体系结构：性能设计（原书第8版） (（美）William Stallings) `9.2.2 节`/`9.3 节`
   - [一篇文章 A systematic approach to teaching binary arithmetic in a first course](https://ieeexplore.ieee.org/document/204838)
7. 真理无穷，追求真理的乐趣亦无穷. -- 《胡适谈读书》