>目标：RSA算法原理和安全性

>核心在 四 "关于 RSA"
## 一、名词$知识点
1. 质数(素数)$合数：
    - 质数：质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数，这样的数称为质数。
        - 任意两个质数构成互质关系，比如13和61。
    - 合数：合数，数学用语，英文名为Composite number，指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数（如：4，6，8，9，10）。
2. 互质：互质是公约数只有1的两个整数，叫做互质整数。公约数只有1的两个自然数，叫做互质自然数，后者是前者的特殊情形。


## 二、欧拉函数及其证明
-  2.1 __欧拉函数：__ 欧拉函数是指：对于一个正整数 n ，小于 n 且和 n 互质的正整数（包括 1）的个数，记作 φ(n) 。
    - 在1到8之中，有多少个数与8构成互质关系？↓↓↓
    1. __如果n=1，__ 则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。
    2. __如果n是质数，__ 则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。
    3. __如果n是质数的某一个次方，__ 即 n = p^k (p为质数，k为大于等于1的整数)，则
        - ![RSA欧拉函数_次方](Image\RSA欧拉函数_次方.png)
        - 比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。
        - 这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、...、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。
        - 上面的式子还可以写成下面的形式：
        -  ![RSA欧拉函数_次方_1.png](Image\RSA欧拉函数_次方_1.png)
        - 可以看出，上面的第二种情况是 k=1 时的特例。
    4. __如果n可以分解成两个互质的整数之积，__ 
        - n = p1 × p2
        - 则
        - φ(n) = φ(p1p2) = φ(p1)φ(p2)
        - 即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。
    5. 因为任意一个大于1的正整数，都可以写成一系列质数的积。
        - ![RSA欧拉函数_任意.png](Image\RSA欧拉函数_任意.png)
    
    6. 根据第4条的结论，得到 
        - ![RSA欧拉函数_4推论.png](Image\RSA欧拉函数_4推论.png)
    7. 再根据第3条的结论，得到
        - ![RSA欧拉函数_3推论1.png](Image\RSA欧拉函数_3推论1.png)
        - 也就等于
        - ![RSA欧拉函数_3推论2.png](Image\RSA欧拉函数_3推论2.png)
    8. 这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：
        - ![RSA欧拉函数_3推论2.png](Image\RSA欧拉函数_使用.png)
        
-  2.2 __有关性质：__  
    - 2.2.1、对于素数 p ，φ(p) = p-1 。
    - 2.2.2、当gcd(n,m)=1时，φ(nm)=φ(n)∗φ(m) 
        - n和m的最大公约数是1,就是互质。gcd就是最大公约数的意思。
    - 2.2.3、对于两个不同素数 p， q ，它们的乘积 n = p * q 满足 __φ(n) = (p -1) * (q -1)__  。[由2.2.1和2.2.2易知]
    - 2.2.4、参考链接有更多。
## 三、模反元素
- 3.1、模反元素：如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a的“模反元素”。
    - 欧拉定理可以用来证明模反元素必然存在。
    - ab ≡ 1 (mod n)
- 定义：`ab≡1（mod n）等价于存在整数t,使得ab+nt=1`
    - 有人说"定义就是规定不需要证明"(-_-),我暂时先接受这说法吧。

## 三.八、欧几里得算法$辗转相除法
辗转相除法， 又名欧几里德算法（Euclidean algorithm），是求最大公约数的一种方法。它的具体做法是：用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。

## 三.九、扩展欧几里得算法
- 扩展欧几里德算法是用来在已知a, b求解一组x，y，使它们满足贝祖等式： ax+by = gcd(a, b) =d（解一定存在，根据数论中的相关定理）

## 四、关于 RSA
现在假设 monkey 和 dog 要通信了(这一过程由monkey产生密钥对)：

- 4.1、随机选择两个不相等的质数 p 和 q
    - monkey选中了61和53。（实际应用中，这两个质数越大，就越难破解。）
- 4.2、计算p和q的乘积n。
    - n = 61×53 = 3233
    - n的二进制长度就是密钥长度。3233写成二进制是 1100 1010 0001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。
- 4.3、计算n的欧拉函数φ(n)。
    - 公式：φ(n) = (p-1)(q-1)
    - φ(3233) = φ(61*53)  
    - 由2.2.3知道 `φ(3233) = φ(61*53) = 60*52 = 3120`
- 4.4、随机选择一个整数e，条件是`1< e < φ(n)`，且e与φ(n) 互质
    - monkey选择了 e=17 。（实际应用中，常常选择65537。）
- 4.5、计算e对于φ(n)的模反元素d
    - ed ≡ 1 (mod φ(n))
    - 所谓"模反元素"就是指有一个整数d，可以使得ed被φ(n)除的余数为1。
    - ed -1 = k*φ(n)
    - 看下已知数：e =17 ; φ(n) = 3120
    - `17d - 1 = 3120k  <=>  17d + (-3120k) = 1  <=>  17d + 3120(-k) = 1`
    - 这个方程可以用"扩展欧几里得算法"求解。 总之，monkey算出一组整数解为 (d,k)=(2753,15)，即 d=2753。
        - 这个计算过程暂时是不理解的(就接受吧)：
            - (原址)http://blog.csdn.net/zhjchengfeng5/article/details/7786595
            - (镜像)http://blog.csdn.net/stray_lambs/article/details/52133141
- 4.6、将n和e封装成公钥，n和d封装成私钥
    - 在本例中，n=3233，e=17，d=2753，所以 __公钥就是 (n,e)=(3233,17)__ ， __私钥就是 (n,d)=(3233, 2753)__ 。
        - 实际应用中，公钥和私钥的数据都采用ASN.1格式表达-(尚未找到实例)
- 4.7、RSA算法的可靠性
    - 4.7.1、密钥生成过程中出现的数字(6个)：
        ```log
          p   -> 随机选择两个不相等的质数 p 和 q
          q   -> 随机选择两个不相等的质数 p 和 q
          n   -> n = p * q
         φ(n) -> 计算n的欧拉函数 > φ(n) = (p-1)(q-1)
          e   -> 随机选择一个整数e，条件是`1< e < φ(n)`，且e与φ(n) 互质
          d   -> 计算e对于φ(n)的模反元素d：ed ≡ 1 (mod φ(n))
        ```
    - 4.7.2、这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。
    - 4.7.3、那么，有无可能在已知n和e的情况下，推导出d？
        - 这里我没有理解作者的思路
        - 我的(正向思维)思路：
            - 整个计算过程已知
            - n 已知 __所以 p，q 可求得__
            - e 已知 __按照之前的算法，只要得到p，q__ 要得到 d 是可行的。
        - __结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。__
    - 4.7.4、可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：
        >"对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。
        >假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。
        >只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。"

        - 举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。
            >1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413

            它等于这样两个质数的乘积：

            >33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489　　
            ×
            36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917

        - 事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。
## 五、加密和解密
有了公钥和密钥，就能进行加密和解密了。
1. 加密使用公钥(n,e)
    - 假设 dog 要向 monkey 发送加密信息m，他就要用 monkey 的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），__且 m 必须小于n__ 。
    - 所谓"加密"，就是算出下式的c：
        >m^e ≡ c (mod n)

    - monkey 的公钥是 (n,e)=(3233, 17)，dog 的m假设是65，那么可以算出下面的等式：
        >65^17 ≡ 2790 (mod 3233)
    
    - 于是，c 等于2790， dog 就把2790发给了 monkey。
2. 解密要用私钥(n,d)
    - monkey 拿到 dog 发来的2790以后，就用自己的私钥 (n,d)=(3233, 2753) 进行解密。可以证明，下面的等式一定成立：
        >c^d ≡ m (mod n)
    
    - 也就是说，c 的 d 次方除以 n 的余数为 m。现在，c 等于2790，私钥是 (n,d)=(3233, 2753)，那么，monkey 算出
        >2790^2753 ≡ 65 (mod 3233)
    
    - 因此， monkey 知道了 dog 加密前的原文就是65。
3. 至此，"加密--解密"的整个过程全部完成。
    - 我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。
    - 你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种"对称性加密算法"（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。

## 六、私钥解密的证明(略)



## 本文内容收集自如下链接：
1. [RSA算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)
2. [RSA算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)
3. [秀尔算法：破解RSA加密的“不灭神话”](http://netsecurity.51cto.com/art/201508/488766.htm)
    - http://www.jiamisoft.com/blog/18273-suanfa.html
4. [欧拉函数及其证明](http://blog.csdn.net/paxhujing/article/details/51353672)
5. [数论学习笔记 欧拉函数 （一些性质和运用）内置杜教筛](http://blog.csdn.net/yxuanwkeith/article/details/52387873)
6. [为什么ab≡1（mod n）等价于存在整数t,使得ab+nt=1](https://zhidao.baidu.com/question/544583208.html)

- [合数](https://baike.baidu.com/item/%E5%90%88%E6%95%B0/49186?fr=aladdin)
- [质数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin)
- [互质](https://baike.baidu.com/item/%E4%BA%92%E8%B4%A8/577412?fr=aladdin)
- [扩展欧几里德算法](https://baike.baidu.com/item/扩展欧几里德算法/1053275?fr=aladdin)