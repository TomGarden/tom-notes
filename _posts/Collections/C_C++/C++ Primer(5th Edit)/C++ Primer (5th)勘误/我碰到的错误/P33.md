## 一、错误位置
- 中文版(纸质书)33页第五个点号
- 英文版 2.1.2. Type Conversions PDF 第 64页 第五个点号
### 1.2、原文
针对点
- unsigned char c = -1;

翻译版原文
- 当我们赋给无符号类型一个超出它范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。

英文版原文
- If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold.

### 1.3、关键单词：remainder
我认为翻译的没有任何问题。翻译出了原文的意思。

### 1.4、 错误分析
首先个描述本身是错的。
- “`初始值对无符号类型表示数值总数取模`” 这句话的含义：
    - “`-1 Mod 256(char 所能表示的数的个数 0~255) = 255`”
- “`后的余数`”
    - 这是没有道理的，一个数(`255`)无法计算“余数”。

### 1.5、我取信
删去：`后的余数`。

### 1.6、别人的观点
1. [C++ 带符号和无符号char类型赋值超出表示范围的情况](http://www.jianshu.com/p/fa6090563147)


## 二、 运算符 `=` 
运算符(`=`)是由编译器来具体解释的。但是这个解释肯定也是有一个规范的。
- 要确定的解决这个问题有三个途径
    1. 最根本：找到编译器的编写规范
    2. 最靠谱：查看编译器的解释源码/文档
    3. 最简洁：问问有经验的开发者