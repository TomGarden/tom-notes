C/S 架构或者 B/S 架构本质上没有什么不同的。
客户端作为一个信息展示页面，有时候也会存储少量的信息，但是一切的核心业务逻辑都以服务端为准。

**服务端应该秉承一个原则，来自客户端的一切都是恶意的，都是不可信的。**

### 一、 风险常发生于：
1. 服务端无条件相信客户端提交的数据，无条件相信客户端的判断。
2. C(B)/S 的通信可以被中间人轻易的监听，也就是通信数据未加密，可以帮助攻击者快速了解通信逻辑/业务逻辑。

### 二、 我们已知：
1. 客户端的一切加密加固手段都是可以被破解的。
  - 也就是说我们的通信的业务逻辑无论如何都无可避免的可以被攻击者窃取。
  - 但是即使这样我们的加固和加密手段也是必须的，增加攻击的成本。

### 三、 避免通信逻辑被查看的手段 **只能增加难度无法真正避免** 。
1. 使用 HTTPS 进行通讯。
  - 攻击者可以通过自己注册账号，完成业务逻辑并在这个古城中为自己设置代理，从而窃取通信过程和通信逻辑。
2. 在使用HTTPS的基础上对传输的信息进行加密
  1. 对称加密节省资源，攻击者可以通过破解客户端获取秘钥。
  2. 非对称加密浪费资源，攻击者依然可以破解客户端获取秘钥。
  3. 上述二者结合的方式，通过使用对称加密完成通信数据加密，使用非对称加密完成对称密钥的传输。攻击者依然可以获取密钥。
  4. 上述三种方式都可以被攻破
    - 攻击者需要破解客户端的一个完整的通讯过程即可成功破解加密密钥
    - 攻击者需要自己实现加密逻辑才能作为中间人对通信过程产生干预
      - 攻破上述三种逻辑的难度为：
        - 对称:需要实现对称加密解密逻辑
        - 非对称：需要实现非对称加解密逻辑
        - 结合：需要实现对称和非对称加解密逻辑

无法避免上述问题的根本原因就在于客户端代码可以被破解，客户端逻辑可以被还原和识别。

### 四、 增加客户端逻辑被查看的难度
1. 使用 JAVA 完成的代码逻辑极容易被反编译
  - 反编译的几乎没有难度
  - 就 Android 平台来说初步反编译为 SMALI 代码，SMALI 也可以继续反编译为 JAVA 代码
2. 使用 C 完成的代码逻辑反编译有一定难度
  - 反编译后为汇编代码
  - 汇编当然可以被解释为 C 但是会出现失真的情况
    - 专业做逆向 C 的人员都是查看汇编而不是查看根据汇编而生成的 C 伪代码的。
3. 混淆源代码，反编译后增加阅读难度。

至此还是无法避免被攻破，但是还有可为，那就是增加业务的严谨性。

### 五、 增加业务的严谨性
让一切都依赖于服务端的逻辑。

#### 5.1、 关于流程性的业务
假设一个完整的业务流程为：
1. 吃饭
2. 睡觉
3. 打豆豆
4. 笑

如果客户端完成 1\2\3 服务端就会对客户端笑，每一个后一步都依赖于前一步。

当然这个过程的依赖性在服务端和客户端都有体现。

- 就客户端而言：
  - 如果没吃饭，就不能睡觉，
  - 如果没睡觉，就不能打豆豆，
  - 如果没吃/睡/打服务端就不会笑
- 当客户端告诉服务端我已经打完豆豆了，服务端应该笑吗？
  - 当然不应该服务端笑的唯一前提是：客户端吃/睡/打这三件事按顺序完成了。
  - 当客户端对服务端说我吃饭了，服务端因该看看是否睡觉和打豆豆都没有做，如果睡/打/笑，都尚未发生那就回复一声“OK”，否则“ERR”
  - 当客户端对服务端说我睡觉了，服务端应该检查，是否已经吃过饭并且没有打/笑，如果是就回复 “OK”，否则“ERR”。
